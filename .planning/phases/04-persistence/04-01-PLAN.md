---
phase: 04-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/storage/video-store.ts
  - src/hooks/use-video-history.ts
autonomous: true

must_haves:
  truths:
    - "SavedVideo type exists with all required fields"
    - "Storage operations work with IndexedDB via idb-keyval"
    - "useVideoHistory hook loads history on mount without SSR errors"
    - "History state updates when videos are added or removed"
  artifacts:
    - path: "src/types/index.ts"
      provides: "SavedVideo interface"
      contains: "interface SavedVideo"
    - path: "src/lib/storage/video-store.ts"
      provides: "IndexedDB operations via idb-keyval"
      exports: ["saveVideo", "getVideo", "getAllVideos", "deleteVideo", "deleteAllVideos"]
    - path: "src/hooks/use-video-history.ts"
      provides: "React hook for history state with SSR-safe hydration"
      exports: ["useVideoHistory"]
  key_links:
    - from: "src/hooks/use-video-history.ts"
      to: "src/lib/storage/video-store.ts"
      via: "import storage functions"
      pattern: "from '@/lib/storage/video-store'"
    - from: "src/lib/storage/video-store.ts"
      to: "idb-keyval"
      via: "import"
      pattern: "from 'idb-keyval'"
    - from: "src/hooks/use-video-history.ts"
      to: "src/types/index.ts"
      via: "import SavedVideo"
      pattern: "from '@/types'"
---

<objective>
Create the data persistence layer using IndexedDB (via idb-keyval) and a React hook for managing video history state.

Purpose: Establish the foundation for saving processed videos so they persist across sessions. This plan creates the storage operations and state management hook, but not the UI.

Output:
- SavedVideo type added to types
- video-store.ts with idb-keyval CRUD operations
- useVideoHistory hook with SSR-safe loading
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/04-persistence/04-RESEARCH.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb-keyval and create storage module</name>
  <files>
    - package.json
    - src/lib/storage/video-store.ts
  </files>
  <action>
1. Install idb-keyval:
   ```bash
   npm install idb-keyval
   ```

2. Create src/lib/storage/ directory and video-store.ts:

```typescript
import { get, set, del, keys, getMany, delMany } from 'idb-keyval';
import type { SavedVideo } from '@/types';

const VIDEO_PREFIX = 'video:';

export async function saveVideo(video: SavedVideo): Promise<void> {
  await set(`${VIDEO_PREFIX}${video.videoId}`, video);
}

export async function getVideo(videoId: string): Promise<SavedVideo | undefined> {
  return get(`${VIDEO_PREFIX}${videoId}`);
}

export async function getAllVideos(): Promise<SavedVideo[]> {
  const allKeys = await keys();
  const videoKeys = allKeys.filter(k =>
    typeof k === 'string' && k.startsWith(VIDEO_PREFIX)
  );
  const videos = await getMany(videoKeys);
  // Sort by savedAt descending (most recent first)
  return videos.filter(Boolean).sort((a, b) => b.savedAt - a.savedAt);
}

export async function deleteVideo(videoId: string): Promise<void> {
  await del(`${VIDEO_PREFIX}${videoId}`);
}

export async function deleteAllVideos(): Promise<void> {
  const allKeys = await keys();
  const videoKeys = allKeys.filter(k =>
    typeof k === 'string' && k.startsWith(VIDEO_PREFIX)
  );
  await delMany(videoKeys);
}
```

Key patterns:
- VIDEO_PREFIX ensures videos don't collide with future storage needs
- getAllVideos sorts by savedAt descending (most recent first)
- Batch operations (getMany, delMany) for efficiency
  </action>
  <verify>
    - `npm ls idb-keyval` shows package installed
    - `npx tsc --noEmit` passes (may show SavedVideo error until Task 2 completes)
    - src/lib/storage/video-store.ts exists
  </verify>
  <done>
    - idb-keyval installed as dependency
    - video-store.ts provides saveVideo, getVideo, getAllVideos, deleteVideo, deleteAllVideos
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SavedVideo type and create useVideoHistory hook</name>
  <files>
    - src/types/index.ts
    - src/hooks/use-video-history.ts
  </files>
  <action>
1. Append SavedVideo interface to src/types/index.ts:

```typescript
export interface SavedVideo {
  videoId: string;                    // Primary key for lookup
  url: string;                        // Original URL (for display/copy)
  metadata: VideoMetadata;            // Title, author, thumbnail
  transcript: string;                 // Full transcript text
  summary: string;                    // Generated summary
  keyPoints: string;                  // Generated key points
  transcriptSource: TranscriptSource; // 'youtube' | 'assemblyai'
  hasSpeakers: boolean;               // For transcript display
  savedAt: number;                    // Unix timestamp for sorting
}
```

2. Create src/hooks/ directory and use-video-history.ts:

```typescript
import { useState, useEffect, useCallback } from 'react';
import type { SavedVideo } from '@/types';
import { getAllVideos, saveVideo, deleteVideo, getVideo } from '@/lib/storage/video-store';

export function useVideoHistory() {
  const [history, setHistory] = useState<SavedVideo[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load history on mount (client-side only, SSR-safe)
  useEffect(() => {
    getAllVideos()
      .then(setHistory)
      .catch(console.error)
      .finally(() => setIsLoading(false));
  }, []);

  const addVideo = useCallback(async (video: SavedVideo) => {
    await saveVideo(video);
    setHistory(prev => {
      // Remove existing if present (update case - prevents duplicates)
      const filtered = prev.filter(v => v.videoId !== video.videoId);
      return [video, ...filtered];
    });
  }, []);

  const removeVideo = useCallback(async (videoId: string) => {
    await deleteVideo(videoId);
    setHistory(prev => prev.filter(v => v.videoId !== videoId));
  }, []);

  const loadVideo = useCallback(async (videoId: string) => {
    return getVideo(videoId);
  }, []);

  return {
    history,
    isLoading,
    addVideo,
    removeVideo,
    loadVideo,
  };
}
```

Key patterns:
- useState initializes to empty array (consistent for SSR/client)
- useEffect loads from IndexedDB only on client (SSR-safe)
- isLoading starts true, becomes false after load
- Functional state updates (prev => ...) avoid race conditions
- addVideo updates existing record if same videoId (deduplication)
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - SavedVideo interface exists in src/types/index.ts
    - src/hooks/use-video-history.ts exports useVideoHistory
  </verify>
  <done>
    - SavedVideo type defined with all required fields
    - useVideoHistory hook created with SSR-safe hydration pattern
    - Hook returns history, isLoading, addVideo, removeVideo, loadVideo
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls idb-keyval` - Package installed
2. `npx tsc --noEmit` - No type errors
3. Verify exports:
   - src/lib/storage/video-store.ts exports 5 functions
   - src/hooks/use-video-history.ts exports useVideoHistory
   - src/types/index.ts includes SavedVideo interface
</verification>

<success_criteria>
1. idb-keyval installed as dependency
2. SavedVideo type exists with videoId, url, metadata, transcript, summary, keyPoints, transcriptSource, hasSpeakers, savedAt
3. video-store.ts provides CRUD operations for SavedVideo
4. useVideoHistory hook loads history on mount without SSR errors
5. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-persistence/04-01-SUMMARY.md`
</output>
