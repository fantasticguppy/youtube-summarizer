---
phase: 04-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/storage/video-store.ts
  - src/hooks/use-video-history.ts
  - src/components/history-list.tsx
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "Processed videos are automatically saved to IndexedDB on completion"
    - "User can see list of previously processed videos"
    - "User can click a past video and view its transcript/summary instantly"
    - "History persists across page refresh"
    - "Processing same video updates existing record (no duplicates)"
  artifacts:
    - path: "src/types/index.ts"
      provides: "SavedVideo interface"
      contains: "interface SavedVideo"
    - path: "src/lib/storage/video-store.ts"
      provides: "IndexedDB operations via idb-keyval"
      exports: ["saveVideo", "getVideo", "getAllVideos", "deleteVideo"]
    - path: "src/hooks/use-video-history.ts"
      provides: "React hook for history state with SSR-safe hydration"
      exports: ["useVideoHistory"]
    - path: "src/components/history-list.tsx"
      provides: "UI component displaying saved videos"
      exports: ["HistoryList"]
    - path: "src/app/page.tsx"
      provides: "Integration of history with main app flow"
      contains: "useVideoHistory"
  key_links:
    - from: "src/hooks/use-video-history.ts"
      to: "src/lib/storage/video-store.ts"
      via: "import getAllVideos, saveVideo, deleteVideo, getVideo"
      pattern: "from '@/lib/storage/video-store'"
    - from: "src/app/page.tsx"
      to: "src/hooks/use-video-history.ts"
      via: "useVideoHistory hook call"
      pattern: "useVideoHistory\\(\\)"
    - from: "src/app/page.tsx"
      to: "src/components/history-list.tsx"
      via: "HistoryList component render"
      pattern: "<HistoryList"
    - from: "src/lib/storage/video-store.ts"
      to: "idb-keyval"
      via: "import"
      pattern: "from 'idb-keyval'"
---

<objective>
Add local persistence so users can save and revisit previously processed videos without re-processing.

Purpose: Complete the core YouTube Summarizer experience by allowing users to build a library of processed videos that persists across sessions. Currently, all results are lost on page refresh.

Output:
- SavedVideo type added to types
- video-store.ts with idb-keyval operations
- useVideoHistory hook with SSR-safe loading
- HistoryList component showing saved videos
- page.tsx integration saving on completion, restoring on select
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/04-persistence/04-RESEARCH.md
@src/types/index.ts
@src/app/page.tsx
@src/components/results-tabs.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage layer with idb-keyval</name>
  <files>
    - src/types/index.ts
    - src/lib/storage/video-store.ts
  </files>
  <action>
1. Install idb-keyval:
   ```bash
   npm install idb-keyval
   ```

2. Add SavedVideo interface to src/types/index.ts (append to existing file):
   ```typescript
   export interface SavedVideo {
     videoId: string;                    // Primary key for lookup
     url: string;                        // Original URL (for display/copy)
     metadata: VideoMetadata;            // Title, author, thumbnail
     transcript: string;                 // Full transcript text
     summary: string;                    // Generated summary
     keyPoints: string;                  // Generated key points
     transcriptSource: TranscriptSource; // 'youtube' | 'assemblyai'
     hasSpeakers: boolean;               // For transcript display
     savedAt: number;                    // Unix timestamp for sorting
   }
   ```

3. Create src/lib/storage/video-store.ts:
   ```typescript
   import { get, set, del, keys, getMany, delMany } from 'idb-keyval';
   import { SavedVideo } from '@/types';

   const VIDEO_PREFIX = 'video:';

   export async function saveVideo(video: SavedVideo): Promise<void> {
     await set(`${VIDEO_PREFIX}${video.videoId}`, video);
   }

   export async function getVideo(videoId: string): Promise<SavedVideo | undefined> {
     return get(`${VIDEO_PREFIX}${videoId}`);
   }

   export async function getAllVideos(): Promise<SavedVideo[]> {
     const allKeys = await keys();
     const videoKeys = allKeys.filter(k =>
       typeof k === 'string' && k.startsWith(VIDEO_PREFIX)
     );
     const videos = await getMany(videoKeys);
     // Sort by savedAt descending (most recent first)
     return videos.filter(Boolean).sort((a, b) => b.savedAt - a.savedAt);
   }

   export async function deleteVideo(videoId: string): Promise<void> {
     await del(`${VIDEO_PREFIX}${videoId}`);
   }

   export async function deleteAllVideos(): Promise<void> {
     const allKeys = await keys();
     const videoKeys = allKeys.filter(k =>
       typeof k === 'string' && k.startsWith(VIDEO_PREFIX)
     );
     await delMany(videoKeys);
   }
   ```
  </action>
  <verify>
    - `npm ls idb-keyval` shows package installed
    - `npx tsc --noEmit` passes (no type errors)
    - SavedVideo interface exists in src/types/index.ts
    - video-store.ts exports all 5 functions
  </verify>
  <done>
    - idb-keyval installed as dependency
    - SavedVideo type defined with all required fields
    - video-store.ts provides saveVideo, getVideo, getAllVideos, deleteVideo, deleteAllVideos
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useVideoHistory hook with SSR-safe hydration</name>
  <files>
    - src/hooks/use-video-history.ts
  </files>
  <action>
Create src/hooks/use-video-history.ts (create hooks directory if needed):

```typescript
import { useState, useEffect, useCallback } from 'react';
import { SavedVideo } from '@/types';
import { getAllVideos, saveVideo, deleteVideo, getVideo } from '@/lib/storage/video-store';

export function useVideoHistory() {
  const [history, setHistory] = useState<SavedVideo[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // Load history on mount (client-side only, SSR-safe)
  useEffect(() => {
    getAllVideos()
      .then(setHistory)
      .catch(console.error)
      .finally(() => setIsLoading(false));
  }, []);

  const addVideo = useCallback(async (video: SavedVideo) => {
    await saveVideo(video);
    setHistory(prev => {
      // Remove existing if present (update case)
      const filtered = prev.filter(v => v.videoId !== video.videoId);
      return [video, ...filtered];
    });
  }, []);

  const removeVideo = useCallback(async (videoId: string) => {
    await deleteVideo(videoId);
    setHistory(prev => prev.filter(v => v.videoId !== videoId));
  }, []);

  const loadVideo = useCallback(async (videoId: string) => {
    return getVideo(videoId);
  }, []);

  return {
    history,
    isLoading,
    addVideo,
    removeVideo,
    loadVideo,
  };
}
```

Key patterns:
- useState initializes to empty array (consistent for SSR/client)
- useEffect loads from IndexedDB only on client
- isLoading starts true, becomes false after load
- Functional state updates (prev => ...) avoid race conditions
- Error caught and logged, doesn't break app
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - src/hooks/use-video-history.ts exists and exports useVideoHistory
  </verify>
  <done>
    - useVideoHistory hook created with SSR-safe hydration pattern
    - Returns history, isLoading, addVideo, removeVideo, loadVideo
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HistoryList component and integrate with page</name>
  <files>
    - src/components/history-list.tsx
    - src/app/page.tsx
  </files>
  <action>
1. Create src/components/history-list.tsx:

```typescript
'use client';

import { SavedVideo } from '@/types';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { Trash2 } from 'lucide-react';

interface HistoryListProps {
  videos: SavedVideo[];
  onSelect: (video: SavedVideo) => void;
  onDelete: (videoId: string) => void;
  isLoading?: boolean;
}

function getRelativeTime(timestamp: number): string {
  const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
  const now = Date.now();
  const diff = timestamp - now;
  const diffMinutes = Math.round(diff / 60000);
  const diffHours = Math.round(diff / 3600000);
  const diffDays = Math.round(diff / 86400000);

  if (Math.abs(diffMinutes) < 60) {
    return rtf.format(diffMinutes, 'minute');
  } else if (Math.abs(diffHours) < 24) {
    return rtf.format(diffHours, 'hour');
  } else {
    return rtf.format(diffDays, 'day');
  }
}

export function HistoryList({ videos, onSelect, onDelete, isLoading }: HistoryListProps) {
  if (isLoading) {
    return (
      <div className="space-y-2">
        <h2 className="text-lg font-semibold">Recent Videos</h2>
        {[1, 2, 3].map(i => (
          <Skeleton key={i} className="h-16 w-full" />
        ))}
      </div>
    );
  }

  if (videos.length === 0) {
    return null; // Don't show section if no history
  }

  return (
    <div className="space-y-2">
      <h2 className="text-lg font-semibold">Recent Videos</h2>
      <div className="space-y-2">
        {videos.map(video => (
          <Card
            key={video.videoId}
            className="p-3 cursor-pointer hover:bg-accent/50 transition-colors"
            onClick={() => onSelect(video)}
          >
            <div className="flex items-center gap-3">
              <img
                src={video.metadata.thumbnailUrl}
                alt=""
                className="w-20 h-12 object-cover rounded"
              />
              <div className="flex-1 min-w-0">
                <p className="font-medium truncate">{video.metadata.title}</p>
                <p className="text-sm text-muted-foreground">
                  {video.metadata.authorName} â€¢ {getRelativeTime(video.savedAt)}
                </p>
              </div>
              <Button
                variant="ghost"
                size="icon"
                onClick={(e) => {
                  e.stopPropagation();
                  onDelete(video.videoId);
                }}
                className="shrink-0"
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

2. Update src/app/page.tsx:

Add imports at top:
```typescript
import { useVideoHistory } from '@/hooks/use-video-history';
import { HistoryList } from '@/components/history-list';
import { SavedVideo } from '@/types';
```

Inside Home component, add after existing useState calls:
```typescript
const { history, isLoading: historyLoading, addVideo, removeVideo } = useVideoHistory();
const [currentVideoId, setCurrentVideoId] = useState<string | null>(null);
```

Modify handleSubmit to save video after successful completion:
- After setStatus('complete'), add:
```typescript
// Save to history
const savedVideo: SavedVideo = {
  videoId: result.videoId,
  url,
  metadata: result.metadata,
  transcript: result.transcript,
  summary: accumulated from summaryFetch,
  keyPoints: accumulated from keyPointsFetch,
  transcriptSource: result.transcriptSource,
  hasSpeakers: result.hasSpeakers,
  savedAt: Date.now(),
};
addVideo(savedVideo);
setCurrentVideoId(result.videoId);
```

Note: Since summary and keyPoints are accumulated in the IIFE closures, you need to capture final values. Refactor to track accumulated values outside the IIFEs:
```typescript
let finalSummary = '';
let finalKeyPoints = '';

await Promise.all([
  (async () => {
    // ... existing code ...
    finalSummary = accumulated;
  })(),
  (async () => {
    // ... existing code ...
    finalKeyPoints = accumulated;
  })()
]);

// After Promise.all completes:
const savedVideo: SavedVideo = {
  videoId: result.videoId,
  url,
  metadata: result.metadata,
  transcript: result.transcript,
  summary: finalSummary,
  keyPoints: finalKeyPoints,
  transcriptSource: result.transcriptSource,
  hasSpeakers: result.hasSpeakers,
  savedAt: Date.now(),
};
await addVideo(savedVideo);
setCurrentVideoId(result.videoId);
setStatus('complete');
```

Add handler for selecting from history (add before return):
```typescript
const handleSelectHistory = useCallback((video: SavedVideo) => {
  // Restore video state without re-processing
  setMetadata(video.metadata);
  setTranscript(video.transcript);
  setSummary(video.summary);
  setKeyPoints(video.keyPoints);
  setTranscriptSource(video.transcriptSource);
  setHasSpeakers(video.hasSpeakers);
  setCurrentVideoId(video.videoId);
  setStatus('complete');
  setError(null);
}, []);

const handleDeleteHistory = useCallback(async (videoId: string) => {
  await removeVideo(videoId);
  // If currently viewing this video, clear it
  if (currentVideoId === videoId) {
    setMetadata(null);
    setTranscript('');
    setSummary('');
    setKeyPoints('');
    setStatus('idle');
    setCurrentVideoId(null);
  }
}, [removeVideo, currentVideoId]);
```

Add HistoryList to JSX, after UrlInput and before ProcessingStatus:
```typescript
<HistoryList
  videos={history}
  onSelect={handleSelectHistory}
  onDelete={handleDeleteHistory}
  isLoading={historyLoading}
/>
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds
    - Manual test: Process a video, refresh page, history shows video, click to restore
    - Manual test: Delete from history works
    - Manual test: Process same video twice, only one entry in history (updated)
  </verify>
  <done>
    - HistoryList component displays saved videos with thumbnail, title, author, relative time
    - Clicking history item restores full state (transcript, summary, keyPoints) instantly
    - Delete button removes from history
    - Processing a video automatically saves to history on completion
    - Re-processing same video updates existing entry (no duplicates)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` - Full build succeeds
2. `npm run dev` - App starts without errors
3. Process a video - Should complete and show in history
4. Refresh page - History persists, shows processed video
5. Click history item - Loads transcript/summary/keyPoints instantly (no API calls)
6. Delete from history - Item removed
7. Process same video again - Updates existing entry, no duplicate
8. Check DevTools > Application > IndexedDB - Data stored under keyval-store
</verification>

<success_criteria>
1. Processed videos automatically saved to IndexedDB on completion
2. History list visible on page with thumbnails, titles, relative timestamps
3. Clicking history item instantly restores full results (no re-processing)
4. History persists across browser sessions/page refreshes
5. Delete functionality works
6. No SSR hydration errors (history loads client-side only)
7. Deduplication: re-processing same video updates existing record
</success_criteria>

<output>
After completion, create `.planning/phases/04-persistence/04-01-SUMMARY.md`
</output>
